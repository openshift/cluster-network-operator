apiVersion: v1
kind: ConfigMap
metadata:
  name: ovnkube-script-lib
  namespace: openshift-ovn-kubernetes
  annotations:
    kubernetes.io/description: |
      This is a script used by the ovn-kubernetes daemonset
    release.openshift.io/version: "{{.ReleaseVersion}}"
data:
  ovnkube-lib.sh: |-
    #!/bin/bash
    set -x

    # Add node-specific overrides if the container has mounted any
    K8S_NODE=${K8S_NODE:-}
    if [[ -n "${K8S_NODE}" && -f "/env/${K8S_NODE}" ]]; then
      set -o allexport
      source "/env/${K8S_NODE}"
      set +o allexport
    fi

    northd_pidfile="/var/run/ovn/ovn-northd.pid"
    controller_pidfile="/var/run/ovn/ovn-controller.pid"
    controller_logfile="/var/log/ovn/acl-audit-log.log"
    vswitch_dbsock="/var/run/openvswitch/db.sock"

    # start-ovn-controller() starts ovn-controller and does not return until
    # ovn-controller exits
    #
    # Requires the following volume mounts:
    #   /run/openvswitch
    #   /run/ovn/
    #   /etc/openvswitch
    #   /etc/ovn/
    #   /var/lib/openvswitch
    #   /var/log/ovn/
    #   /dev/log
    start-ovn-controller()
    {
      local log_level=$1

      if [[ $# -ne 1 ]]; then
        echo "Expected one argument but got $#"
        exit 1
      fi

      echo "$(date -Iseconds) - starting ovn-controller"
      exec ovn-controller \
        unix:${vswitch_dbsock} \
        -vfile:off \
        --no-chdir \
        --pidfile=${controller_pidfile} \
        --syslog-method="{{.OVNPolicyAuditDestination}}" \
        --log-file=${controller_logfile} \
        -vFACILITY:"{{.OVNPolicyAuditSyslogFacility}}" \
        -vconsole:"${log_level}" \
        -vconsole:"acl_log:off" \
        -vPATTERN:console:"{{.OVN_LOG_PATTERN_CONSOLE}}" \
        -vsyslog:"acl_log:info" \
        -vfile:"acl_log:info"
    }

    # quit-ovn-northd() will cleanly shut down ovn-northd. It is intended
    # to be run from a bash 'trap' like so:
    #
    #    trap quit-ovn-northd TERM INT
    quit-ovn-northd()
    {
      echo "$(date -Iseconds) - stopping ovn-northd"
      OVN_MANAGE_OVSDB=no /usr/share/ovn/scripts/ovn-ctl stop_northd
      echo "$(date -Iseconds) - ovn-northd stopped"
      rm -f ${northd_pidfile}
      exit 0
    }

    # run-ovn-northd() starts ovn-northd and does not return until
    # northd exits.
    #
    # Requires the following volume mounts:
    #   /etc/openvswitch/
    #   /var/lib/openvswitch/
    #   /run/openvswitch/
    #   /run/ovn/
    #   /var/log/ovn/
    start-ovn-northd()
    {
      local log_level=$1

      if [[ $# -ne 1 ]]; then
        echo "Expected one argument but got $#"
        exit 1
      fi

      echo "$(date -Iseconds) - starting ovn-northd"
      exec ovn-northd \
        --no-chdir \
        -vconsole:"${log_level}" \
        -vfile:off \
        -vPATTERN:console:"{{.OVN_LOG_PATTERN_CONSOLE}}" \
        --pidfile ${northd_pidfile} \
        --n-threads={{.NorthdThreads}} &
      wait $!
    }

    # start-audit-log-rotation() continuously watches ovn-controller's audit
    # log directory and deletes old logs to ensure the total size of the logs
    # does not exceed a given threshold. This function does not return.
    #
    # Requires the following volume mounts:
    #   /var/log/ovn/
    #   /run/ovn/
    start-audit-log-rotation()
    {
      # Rotate audit log files when then get to max size (in bytes)
      MAXFILESIZE=$(( "{{.OVNPolicyAuditMaxFileSize}}"*1000000 ))
      MAXLOGFILES="{{.OVNPolicyAuditMaxLogFiles}}"
      LOGDIR=$(dirname ${controller_logfile})
      CONTROLLERPID=$(cat ${controller_pidfile})

      # Redirect err to null so no messages are shown upon rotation
      tail -F ${controller_logfile} 2> /dev/null &

      while true
      do
        # Make sure ovn-controller's logfile exists, and get current size in bytes
        if [ -f "${controller_logfile}" ]; then
          file_size=`du -b ${controller_logfile} | tr -s '\t' ' ' | cut -d' ' -f1`
        else
          ovs-appctl -t /var/run/ovn/ovn-controller.${CONTROLLERPID}.ctl vlog/reopen
          file_size=`du -b ${controller_logfile} | tr -s '\t' ' ' | cut -d' ' -f1`
        fi

        if [ $file_size -gt $MAXFILESIZE ];then
          echo "Rotating OVN ACL Log File"
          timestamp=`date '+%Y-%m-%dT%H-%M-%S'`
          mv ${controller_logfile} ${LOGDIR}/acl-audit-log.$timestamp.log
          ovs-appctl -t /run/ovn/ovn-controller.${CONTROLLERPID}.ctl vlog/reopen
          CONTROLLERPID=$(cat ${controller_pidfile})
        fi

        # Ensure total number of log files does not exceed the maximum configured from OVNPolicyAuditMaxLogFiles
        num_files=$(ls -1 ${LOGDIR}/acl-audit-log* 2>/dev/null | wc -l)
        if [ "$num_files" -gt "$MAXLOGFILES" ]; then
          num_to_delete=$(( num_files - ${MAXLOGFILES} ))
          ls -1t ${LOGDIR}/acl-audit-log* 2>/dev/null | tail -$num_to_delete | xargs -I {} rm {}
        fi

        # sleep for 30 seconds to avoid wasting CPU
        sleep 30
      done
    }

    wait-for-certs()
    {
      local detail=$1
      local privkey=$2
      local clientcert=$3

      if [[ $# -ne 3 ]]; then
        echo "Expected three arguments but got $#"
        exit 1
      fi

      retries=0
      TS=$(date +%s)
      WARN_TS=$(( ${TS} + $(( 20 * 60)) ))
      HAS_LOGGED_INFO=0
      while [[ ! -f "${privkey}" ||  ! -f "${clientcert}" ]] ; do
        CUR_TS=$(date +%s)
        if [[ "${CUR_TS}" -gt "WARN_TS"  ]]; then
          echo "$(date -Iseconds) WARN: ${detail} certs not mounted after 20 minutes."
        elif [[ "${HAS_LOGGED_INFO}" -eq 0 ]] ; then
          echo "$(date -Iseconds) INFO: ${detail} certs not mounted. Waiting one hour."
          HAS_LOGGED_INFO=1
        fi
        sleep 5
      done
    }

    # start-rbac-proxy() starts the kube-rbac-proxy to expose ovnkube metrics to
    # Prometheus on the given listen_port, proxying from upstream_port. This
    # function does not return.
    #
    # Requires the following volume mounts:
    #   /etc/pki/tls/metrics-cert
    start-rbac-proxy-node()
    {
      local detail=$1
      local listen_port=$2
      local upstream_port=$3
      local privkey=$4
      local clientcert=$5

      if [[ $# -ne 5 ]]; then
        echo "Expected five arguments but got $#"
        exit 1
      fi

      # As the secret mount is optional we must wait for the files to be present.
      # The service is created in monitor.yaml and this is created in sdn.yaml.
      # If it isn't created there is probably an issue so we want to crashloop.
      echo "$(date -Iseconds) INFO: waiting for ${detail} certs to be mounted"
      wait-for-certs "${detail}" "${privkey}" "${clientcert}"

      echo "$(date -Iseconds) INFO: ${detail} certs mounted, starting kube-rbac-proxy"
      exec /usr/bin/kube-rbac-proxy \
        --logtostderr \
        --secure-listen-address=:${listen_port} \
        --tls-cipher-suites=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 \
        --upstream=http://127.0.0.1:${upstream_port}/ \
        --tls-private-key-file=${privkey} \
        --tls-cert-file=${clientcert}
    }
